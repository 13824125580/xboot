/*
 * xboot/kernel/command/cmd_test.c
 */

#include <configs.h>
#include <default.h>
#include <types.h>
#include <string.h>
#include <malloc.h>
#include <rand.h>
#include <div64.h>
#include <fifo.h>
#include <vsprintf.h>
#include <byteorder.h>
#include <sha.h>
#include <xml.h>
#include <time/delay.h>
#include <time/timer.h>
#include <time/xtime.h>
#include <time/tick.h>
#include <xboot/list.h>
#include <xboot/io.h>
#include <xboot/log.h>
#include <xboot/irq.h>
#include <xboot/printk.h>
#include <xboot/scank.h>
#include <xboot/initcall.h>
#include <xboot/resource.h>
#include <xboot/chrdev.h>
#include <shell/env.h>
#include <shell/command.h>
#include <fb/fb.h>
#include <loop/loop.h>
#include <fb/graphic.h>
#include <fb/logo.h>
#include <rtc/rtc.h>
#include <xboot/proc.h>
#include <terminal/terminal.h>
#include <terminal/curses.h>
#include <mmc/mmc.h>
#include <mmc/mmc_host.h>
#include <fs/vfs/vfs.h>
#include <fs/fsapi.h>


#if	defined(CONFIG_COMMAND_TEST) && (CONFIG_COMMAND_TEST > 0)

static const x_u8 test_ar[206] = {
	0x21, 0x3c, 0x61, 0x72, 0x63, 0x68, 0x3e, 0x0a, 0x33, 0x2e,
	0x74, 0x78, 0x74, 0x2f, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
	0x20, 0x20, 0x20, 0x20, 0x31, 0x32, 0x36, 0x33, 0x38, 0x36,
	0x34, 0x30, 0x37, 0x31, 0x20, 0x20, 0x31, 0x30, 0x30, 0x30,
	0x20, 0x20, 0x31, 0x30, 0x30, 0x30, 0x20, 0x20, 0x31, 0x30,
	0x30, 0x36, 0x34, 0x34, 0x20, 0x20, 0x36, 0x20, 0x20, 0x20,
	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x60, 0x0a, 0x49, 0x27,
	0x6d, 0x20, 0x33, 0x0a, 0x31, 0x2e, 0x74, 0x78, 0x74, 0x2f,
	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
	0x31, 0x32, 0x36, 0x33, 0x38, 0x36, 0x34, 0x30, 0x33, 0x33,
	0x20, 0x20, 0x31, 0x30, 0x30, 0x30, 0x20, 0x20, 0x31, 0x30,
	0x30, 0x30, 0x20, 0x20, 0x31, 0x30, 0x30, 0x36, 0x34, 0x34,
	0x20, 0x20, 0x36, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
	0x20, 0x20, 0x60, 0x0a, 0x49, 0x27, 0x6d, 0x20, 0x31, 0x0a,
	0x32, 0x2e, 0x74, 0x78, 0x74, 0x2f, 0x20, 0x20, 0x20, 0x20,
	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x31, 0x32, 0x36, 0x33,
	0x38, 0x36, 0x34, 0x30, 0x34, 0x30, 0x20, 0x20, 0x31, 0x30,
	0x30, 0x30, 0x20, 0x20, 0x31, 0x30, 0x30, 0x30, 0x20, 0x20,
	0x31, 0x30, 0x30, 0x36, 0x34, 0x34, 0x20, 0x20, 0x36, 0x20,
	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x60, 0x0a,
	0x49, 0x27, 0x6d, 0x20, 0x32, 0x0a
};

static x_s32 test(x_s32 argc, const x_s8 **argv)
{
	x_s32 fd;
	x_s32 n;

	fd = open("test.ar", O_WRONLY | O_CREAT | O_TRUNC, (S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH));
	if(fd < 0)
		return -1;

	n = write(fd, (void *)test_ar, 206);
	if( n != 206 )
	{
		close(fd);
		unlink("test.ar");
		printk("failed to write test.ar\r\n");
	}
	close(fd);
	printk("write test.ar\r\n");

	return 0;
}

static struct command test_cmd = {
	.name		= "test",
	.func		= test,
	.desc		= "test command for debug\r\n",
	.usage		= "test [arg ...]\r\n",
	.help		= "    test command for debug software by programmer.\r\n"
};

static __init void test_cmd_init(void)
{
	if(!command_register(&test_cmd))
		LOG_E("register 'test' command fail");
}

static __exit void test_cmd_exit(void)
{
	if(!command_unregister(&test_cmd))
		LOG_E("unregister 'test' command fail");
}

module_init(test_cmd_init, LEVEL_COMMAND);
module_exit(test_cmd_exit, LEVEL_COMMAND);

#endif
